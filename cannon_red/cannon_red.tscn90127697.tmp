[gd_scene load_steps=52 format=3 uid="uid://ddbjns5jmx5q2"]

[ext_resource type="Script" uid="uid://bb5uwibh6bw4s" path="res://cannon_red/cannon_red.gd" id="1_7yoq5"]
[ext_resource type="Script" uid="uid://enntb2jocitf" path="res://Character.gd" id="2_fkf0j"]
[ext_resource type="PackedScene" uid="uid://b2h2bq4y0qfv5" path="res://systems/cannon/cannon.tscn" id="3_a6f0r"]
[ext_resource type="Texture2D" uid="uid://bu2go1wvae3wv" path="res://cannon_red/sprites/cannon.png" id="4_lgn7a"]
[ext_resource type="Texture2D" uid="uid://btuq3rsjojo1u" path="res://cannon_red/sprites/cannon_red_shoot.png" id="5_guiwg"]
[ext_resource type="Texture2D" uid="uid://qweheydjcqu7" path="res://cannon_red/sprites/cannon_red_bg.png" id="6_80m7a"]
[ext_resource type="PackedScene" uid="uid://cw0tkif0ebdws" path="res://systems/damage/hurtbox.tscn" id="6_guiwg"]
[ext_resource type="PackedScene" uid="uid://cqmv7o0lm7pk6" path="res://systems/damage/hitbox.tscn" id="7_80m7a"]
[ext_resource type="Script" uid="uid://diqau2lm11fjd" path="res://cannon_red/face_player.gd" id="8_1dixw"]
[ext_resource type="PackedScene" uid="uid://dp4u0ehqdagfh" path="res://GUI/enemy_healthbar/enemy_healthbar.tscn" id="9_i6ngp"]

[sub_resource type="Animation" id="Animation_lgn7a"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("AnimatedSprite2D:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"idle"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("AnimatedSprite2D:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(0, 0)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("AnimatedSprite2D:frame")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [0]
}

[sub_resource type="Animation" id="Animation_a6f0r"]
resource_name = "idle"
loop_mode = 1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("AnimatedSprite2D:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"idle"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("AnimatedSprite2D:position")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(),
"transitions": PackedFloat32Array(),
"update": 0,
"values": []
}

[sub_resource type="Animation" id="Animation_80m7a"]
resource_name = "shoot"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("AnimatedSprite2D:animation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 1,
"values": [&"shoot"]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("AnimatedSprite2D:frame")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 1),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [0, 29]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_guiwg"]
_data = {
&"RESET": SubResource("Animation_lgn7a"),
&"idle": SubResource("Animation_a6f0r"),
&"shoot": SubResource("Animation_80m7a")
}

[sub_resource type="AtlasTexture" id="AtlasTexture_80m7a"]
atlas = ExtResource("4_lgn7a")
region = Rect2(0, 0, 89, 41)

[sub_resource type="AtlasTexture" id="AtlasTexture_i6ngp"]
atlas = ExtResource("5_guiwg")
region = Rect2(0, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_0tiaj"]
atlas = ExtResource("5_guiwg")
region = Rect2(90, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_tigjc"]
atlas = ExtResource("5_guiwg")
region = Rect2(180, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_e5lcu"]
atlas = ExtResource("5_guiwg")
region = Rect2(270, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_406xm"]
atlas = ExtResource("5_guiwg")
region = Rect2(360, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_1dixw"]
atlas = ExtResource("5_guiwg")
region = Rect2(450, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_f0x5v"]
atlas = ExtResource("5_guiwg")
region = Rect2(540, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_rtdce"]
atlas = ExtResource("5_guiwg")
region = Rect2(630, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_yaf72"]
atlas = ExtResource("5_guiwg")
region = Rect2(720, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_ldjoq"]
atlas = ExtResource("5_guiwg")
region = Rect2(810, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_xlgap"]
atlas = ExtResource("5_guiwg")
region = Rect2(900, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_an21o"]
atlas = ExtResource("5_guiwg")
region = Rect2(990, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_13pkm"]
atlas = ExtResource("5_guiwg")
region = Rect2(1080, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_55nui"]
atlas = ExtResource("5_guiwg")
region = Rect2(1170, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_5a6qu"]
atlas = ExtResource("5_guiwg")
region = Rect2(1260, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_k2kyv"]
atlas = ExtResource("5_guiwg")
region = Rect2(1350, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_rkfjx"]
atlas = ExtResource("5_guiwg")
region = Rect2(1440, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_dgkrw"]
atlas = ExtResource("5_guiwg")
region = Rect2(1530, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_lcar3"]
atlas = ExtResource("5_guiwg")
region = Rect2(1620, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_5yddd"]
atlas = ExtResource("5_guiwg")
region = Rect2(1710, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_uhqkk"]
atlas = ExtResource("5_guiwg")
region = Rect2(1800, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_q3kmm"]
atlas = ExtResource("5_guiwg")
region = Rect2(1890, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_cmw0w"]
atlas = ExtResource("5_guiwg")
region = Rect2(1980, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_6di6o"]
atlas = ExtResource("5_guiwg")
region = Rect2(2070, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_u1xon"]
atlas = ExtResource("5_guiwg")
region = Rect2(2160, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_0uef0"]
atlas = ExtResource("5_guiwg")
region = Rect2(2250, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_0w7bp"]
atlas = ExtResource("5_guiwg")
region = Rect2(2340, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_uriqa"]
atlas = ExtResource("5_guiwg")
region = Rect2(2430, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_pr1gv"]
atlas = ExtResource("5_guiwg")
region = Rect2(2520, 0, 89, 42)

[sub_resource type="AtlasTexture" id="AtlasTexture_oi2p7"]
atlas = ExtResource("5_guiwg")
region = Rect2(2610, 0, 89, 42)

[sub_resource type="SpriteFrames" id="SpriteFrames_lx6g4"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_80m7a")
}],
"loop": true,
"name": &"idle",
"speed": 1.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_i6ngp")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0tiaj")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tigjc")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_e5lcu")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_406xm")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_1dixw")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_f0x5v")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_rtdce")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_yaf72")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ldjoq")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_xlgap")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_an21o")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_13pkm")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_55nui")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_5a6qu")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_k2kyv")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_rkfjx")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_dgkrw")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_lcar3")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_5yddd")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_uhqkk")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_q3kmm")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_cmw0w")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_6di6o")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_u1xon")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0uef0")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0w7bp")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_uriqa")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_pr1gv")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_oi2p7")
}],
"loop": false,
"name": &"shoot",
"speed": 30.0
}]

[sub_resource type="GDScript" id="GDScript_0tiaj"]
script/source = "@tool
@icon(\"../icons/tree.svg\")
class_name BeehaveTree extends Node

## Controls the flow of execution of the entire behavior tree.

enum { SUCCESS, FAILURE, RUNNING }

enum ProcessThread { IDLE, PHYSICS, MANUAL }

signal tree_enabled
signal tree_disabled

## Whether this behavior tree should be enabled or not.
@export var enabled: bool = true:
	set(value):
		enabled = value
		set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
		set_process(enabled and process_thread == ProcessThread.IDLE)
		if value:
			tree_enabled.emit()
		else:
			interrupt()
			tree_disabled.emit()

	get:
		return enabled

## How often the tree should tick, in frames. The default value of 1 means
## tick() runs every frame.
@export var tick_rate: int = 1

## An optional node path this behavior tree should apply to.
@export_node_path var actor_node_path: NodePath:
	set(anp):
		actor_node_path = anp
		if actor_node_path != null and str(actor_node_path) != \"..\":
			actor = get_node(actor_node_path.get_as_property_path())
		else:
			actor = get_parent()
		if Engine.is_editor_hint():
			update_configuration_warnings()

## Whether to run this tree in a physics or idle thread.
@export var process_thread: ProcessThread = ProcessThread.PHYSICS:
	set(value):
		process_thread = value
		self.enabled = self.enabled and process_thread != ProcessThread.MANUAL
		set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
		set_process(enabled and process_thread == ProcessThread.IDLE)

## Custom blackboard node. An internal blackboard will be used
## if no blackboard is provided explicitly.
@export var blackboard: Blackboard:
	set(b):
		blackboard = b
		if blackboard and _internal_blackboard:
			remove_child(_internal_blackboard)
			_internal_blackboard.free()
			_internal_blackboard = null
		elif not blackboard and not _internal_blackboard:
			_internal_blackboard = Blackboard.new()
			add_child(_internal_blackboard, false, Node.INTERNAL_MODE_BACK)
	get:
		# in case blackboard is accessed before this node is,
		# we need to ensure that the internal blackboard is used.
		if not blackboard and not _internal_blackboard:
			_internal_blackboard = Blackboard.new()
			add_child(_internal_blackboard, false, Node.INTERNAL_MODE_BACK)
		return blackboard if blackboard else _internal_blackboard

## When enabled, this tree is tracked individually
## as a custom monitor.
@export var custom_monitor = false:
	set(b):
		custom_monitor = b
		if custom_monitor and _process_time_metric_name != \"\":
			Performance.add_custom_monitor(
				_process_time_metric_name, _get_process_time_metric_value
			)
			_get_global_metrics().register_tree(self)
		else:
			if _process_time_metric_name != \"\":
				# Remove tree metric from the engine
				Performance.remove_custom_monitor(_process_time_metric_name)
				_get_global_metrics().unregister_tree(self)

			BeehaveDebuggerMessages.unregister_tree(get_instance_id())

@export var actor: Node:
	set(a):
		actor = a
		if actor == null:
			actor = get_parent()
		if Engine.is_editor_hint():
			update_configuration_warnings()

var status: int = -1
var last_tick: int = -1

var _internal_blackboard: Blackboard
var _process_time_metric_name: String
var _process_time_metric_value: float = 0.0
var _can_send_message: bool = false


func _ready() -> void:
	var connect_scene_tree_signal = func(signal_name: String, is_added: bool):
		if not get_tree().is_connected(signal_name, _on_scene_tree_node_added_removed.bind(is_added)):
			get_tree().connect(signal_name, _on_scene_tree_node_added_removed.bind(is_added))
	connect_scene_tree_signal.call(\"node_added\", true)
	connect_scene_tree_signal.call(\"node_removed\", false)

	if not process_thread:
		process_thread = ProcessThread.PHYSICS

	if not actor:
		if actor_node_path:
			actor = get_node(actor_node_path)
		else:
			actor = get_parent()

	if not blackboard:
		# invoke setter to auto-initialise the blackboard.
		self.blackboard = null

	# Get the name of the parent node name for metric
	_process_time_metric_name = (
		\"beehave [microseconds]/process_time_%s-%s\" % [actor.name, get_instance_id()]
	)

	set_physics_process(enabled and process_thread == ProcessThread.PHYSICS)
	set_process(enabled and process_thread == ProcessThread.IDLE)

	# Register custom metric to the engine
	if custom_monitor and not Engine.is_editor_hint():
		Performance.add_custom_monitor(_process_time_metric_name, _get_process_time_metric_value)
		_get_global_metrics().register_tree(self)

	if Engine.is_editor_hint():
		update_configuration_warnings.call_deferred()
	else:
		# Ensure the local debugger knows about the tree *before* telling the editor.
		_get_global_debugger().register_tree(self)
		BeehaveDebuggerMessages.register_tree(_get_debugger_data(self))


func _on_scene_tree_node_added_removed(node: Node, is_added: bool) -> void:
	if Engine.is_editor_hint():
		return

	if node is BeehaveNode and is_ancestor_of(node):
		var sgnal := node.ready if is_added else node.tree_exited
		if is_added:
			sgnal.connect(
				func() -> void: BeehaveDebuggerMessages.register_tree(_get_debugger_data(self)),
				CONNECT_ONE_SHOT
			)
		else:
			sgnal.connect(
				func() -> void:
					BeehaveDebuggerMessages.unregister_tree(get_instance_id())
					request_ready()
			)


func _physics_process(_delta: float) -> void:
	tick()


func _process(_delta: float) -> void:
	tick()


func tick() -> int:
	if Engine.is_editor_hint():
		return -1
	if last_tick != -1 and last_tick < tick_rate - 1:
		last_tick += 1
		return -1

	last_tick = 0

	# Start timing for metric
	var start_time = Time.get_ticks_usec()
	blackboard.set_value(\"can_send_message\", _can_send_message)

	if _can_send_message and not Engine.is_editor_hint():
		BeehaveDebuggerMessages.process_begin(get_instance_id(), blackboard.get_debug_data())

	if actor == null or get_child_count() == 0:
		return FAILURE
	var child := self.get_child(0)
	if status != RUNNING:
		child.before_run(actor, blackboard)

	status = child.tick(actor, blackboard)
	if _can_send_message:
		BeehaveDebuggerMessages.process_tick(child.get_instance_id(), status, blackboard.get_debug_data())
		BeehaveDebuggerMessages.process_tick(get_instance_id(), status, blackboard.get_debug_data())

	# Clear running action if nothing is running
	if status != RUNNING:
		blackboard.set_value(\"running_action\", null, str(actor.get_instance_id()))
		child.after_run(actor, blackboard)
		
	if _can_send_message and not Engine.is_editor_hint():
		BeehaveDebuggerMessages.process_end(get_instance_id(), blackboard.get_debug_data())

	# Check the cost for this frame and save it for metric report
	_process_time_metric_value = Time.get_ticks_usec() - start_time
	
	return status


func _get_configuration_warnings() -> PackedStringArray:
	var warnings: PackedStringArray = []

	if actor == null:
		warnings.append(\"Configure target node on tree\")

	if get_children().any(func(x): return not (x is BeehaveNode)):
		warnings.append(\"All children of this node should inherit from BeehaveNode class.\")

	if get_child_count() != 1:
		warnings.append(\"BeehaveTree should have exactly one child node.\")

	return warnings


## Returns the currently running action
func get_running_action() -> ActionLeaf:
	return blackboard.get_value(\"running_action\", null, str(actor.get_instance_id()))


## Returns the last condition that was executed
func get_last_condition() -> ConditionLeaf:
	return blackboard.get_value(\"last_condition\", null, str(actor.get_instance_id()))


## Returns the status of the last executed condition
func get_last_condition_status() -> String:
	if blackboard.has_value(\"last_condition_status\", str(actor.get_instance_id())):
		var status = blackboard.get_value(
			\"last_condition_status\", null, str(actor.get_instance_id())
		)
		if status == SUCCESS:
			return \"SUCCESS\"
		elif status == FAILURE:
			return \"FAILURE\"
		else:
			return \"RUNNING\"
	return \"\"


## interrupts this tree if anything was running
func interrupt() -> void:
	if self.get_child_count() != 0:
		var first_child = self.get_child(0)
		if \"interrupt\" in first_child:
			first_child.interrupt(actor, blackboard)


## Enables this tree.
func enable() -> void:
	self.enabled = true


## Disables this tree.
func disable() -> void:
	self.enabled = false


func _exit_tree() -> void:
	if Engine.is_editor_hint():
		# Skip this when running in editor
		return
	if custom_monitor:
		if _process_time_metric_name != \"\":
			# Remove tree metric from the engine
			Performance.remove_custom_monitor(_process_time_metric_name)
		_get_global_metrics().unregister_tree(self)
		BeehaveDebuggerMessages.unregister_tree(get_instance_id())


# Called by the engine to profile this tree
func _get_process_time_metric_value() -> int:
	return int(_process_time_metric_value)


func _get_debugger_data(node: Node) -> Dictionary:
	if not (node is BeehaveTree or node is BeehaveNode):
		return {}

	var data := {
		path = node.get_path(),
		name = node.name,
		type = node.get_class_name(),
		id = str(node.get_instance_id())
	}
	if node.get_child_count() > 0:
		data.children = []
	for child in node.get_children():
		var child_data := _get_debugger_data(child)
		if not child_data.is_empty():
			data.children.push_back(child_data)
	return data


func get_class_name() -> Array[StringName]:
	return [&\"BeehaveTree\"]


# required to avoid lifecycle issues on initial load
# due to loading order problems with autoloads
func _get_global_metrics() -> Node:
	return get_tree().root.get_node(\"BeehaveGlobalMetrics\")


# required to avoid lifecycle issues on initial load
# due to loading order problems with autoloads
func _get_global_debugger() -> Node:
	return get_tree().root.get_node(\"BeehaveGlobalDebugger\")
"

[sub_resource type="GDScript" id="GDScript_tigjc"]
script/source = "@tool
@icon(\"../../icons/sequence_reactive.svg\")
class_name SequenceStarComposite extends Composite

## Sequence Star nodes will attempt to execute all of its children and report
## `SUCCESS` in case all of the children report a `SUCCESS` status code.
## If at least one child reports a `FAILURE` status code, this node will also
## return `FAILURE` and tick again.
## In case a child returns `RUNNING` this node will tick again.

var successful_index: int = 0
# Track where we last failed â€“ so we detect a backward jump
var previous_failure_or_running_index: int = -1


func tick(actor: Node, blackboard: Blackboard) -> int:
	var children = get_children()
	for i in range(children.size()):
		var c = children[i]
		if c.get_index() < successful_index:
			continue

		if c != running_child:
			c.before_run(actor, blackboard)

		var response: int = c._safe_tick(actor, blackboard)
		if can_send_message(blackboard):
			BeehaveDebuggerMessages.process_tick(c.get_instance_id(), response, blackboard.get_debug_data())

		if c is ConditionLeaf:
			blackboard.set_value(\"last_condition\", c, str(actor.get_instance_id()))
			blackboard.set_value(\"last_condition_status\", response, str(actor.get_instance_id()))

		match response:
			SUCCESS:
				if running_child != null and running_child == c:
					# do not interrupt as this child finishes running!
					_cleanup_running(running_child, actor, blackboard)
				successful_index += 1
				c.after_run(actor, blackboard)
			FAILURE:
				_interrupt_children(actor, blackboard, i, previous_failure_or_running_index)
				
				# remember where we failed for next tick
				previous_failure_or_running_index = c.get_index()
				
				# Interrupt any child that was RUNNING before
				# but do not reset!
				if running_child != null:
					running_child.interrupt(actor, blackboard)
					_cleanup_running(running_child, actor, blackboard)
				
				c.after_run(actor, blackboard)
				return FAILURE
			RUNNING:
				if running_child != null and running_child != c:
					running_child.interrupt(actor, blackboard)
					_cleanup_running(running_child, actor, blackboard)
				running_child = c
				if c is ActionLeaf:
					blackboard.set_value(\"running_action\", c, str(actor.get_instance_id()))
				_interrupt_children(actor, blackboard, i, previous_failure_or_running_index)
				previous_failure_or_running_index = i
				return RUNNING
	successful_index = 0
	return SUCCESS


func interrupt(actor: Node, blackboard: Blackboard) -> void:
	_interrupt_children(actor, blackboard, successful_index - 1, previous_failure_or_running_index)
	if running_child != null:
		running_child.interrupt(actor, blackboard)
		running_child = null
	_reset()
	super(actor, blackboard)


func _reset() -> void:
	successful_index = 0
	previous_failure_or_running_index = -1


func get_class_name() -> Array[StringName]:
	var classes := super()
	classes.push_back(&\"SequenceStarComposite\")
	return classes
"

[sub_resource type="CircleShape2D" id="CircleShape2D_80m7a"]
radius = 36.124783

[sub_resource type="CircleShape2D" id="CircleShape2D_i6ngp"]
radius = 38.0

[sub_resource type="CircleShape2D" id="CircleShape2D_0tiaj"]
radius = 38.0

[node name="CannonRed" type="CharacterBody2D" node_paths=PackedStringArray("character")]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_7yoq5")
character = NodePath("Character")

[node name="Character" type="Node2D" parent="." node_paths=PackedStringArray("parent_body") groups=["Enemy"]]
script = ExtResource("2_fkf0j")
parent_body = NodePath("..")
max_health = 3
cash_value = 3
metadata/_custom_type_script = "uid://enntb2jocitf"

[node name="Cannon" parent="Character" node_paths=PackedStringArray("animation_player") instance=ExtResource("3_a6f0r")]
unique_name_in_owner = true
collision_layer = 4
collision_mask = 3
animation_player = NodePath("AnimationPlayer")

[node name="AnimationPlayer" type="AnimationPlayer" parent="Character/Cannon"]
libraries = {
&"": SubResource("AnimationLibrary_guiwg")
}

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="Character/Cannon"]
z_index = 2
z_as_relative = false
sprite_frames = SubResource("SpriteFrames_lx6g4")
animation = &"idle"
offset = Vector2(16, 0)

[node name="BeehaveTree" type="Node" parent="Character/Cannon" node_paths=PackedStringArray("actor")]
script = SubResource("GDScript_0tiaj")
actor = NodePath("..")
metadata/_custom_type_script = "uid://bb0t2ovl7wifo"

[node name="SequenceStarComposite" type="Node" parent="Character/Cannon/BeehaveTree"]
script = SubResource("GDScript_tigjc")
metadata/_custom_type_script = "uid://bbaojjriq676j"

[node name="FacePlayer" type="Node" parent="Character/Cannon/BeehaveTree/SequenceStarComposite"]
script = ExtResource("8_1dixw")
metadata/_custom_type_script = "uid://cv74jjdrwevpr"

[node name="BaseSprite" type="Sprite2D" parent="."]
z_index = 1
z_as_relative = false
texture = ExtResource("6_80m7a")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("CircleShape2D_80m7a")

[node name="Hurtbox" parent="." node_paths=PackedStringArray("parent_character") groups=["Enemy"] instance=ExtResource("6_guiwg")]
collision_layer = 4
collision_mask = 2
parent_character = NodePath("../Character")

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("CircleShape2D_i6ngp")

[node name="Hitbox" parent="." groups=["Enemy"] instance=ExtResource("7_80m7a")]
collision_layer = 4
collision_mask = 2
damage = 1
knockback = 300.0

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hitbox"]
shape = SubResource("CircleShape2D_0tiaj")

[node name="Healthbar" parent="." instance=ExtResource("9_i6ngp")]
unique_name_in_owner = true

[connection signal="damaged" from="Character" to="." method="_on_character_damaged"]
[connection signal="died" from="Character" to="." method="_on_character_died"]
[connection signal="take_damage" from="Hurtbox" to="." method="_on_hurtbox_take_damage"]
